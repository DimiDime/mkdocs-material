{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#code-annotation-examples","title":"Code Annotation Examples","text":""},{"location":"#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with the <code>py</code> at the start:</p> <pre><code>import tensorflow as tf\ndef whatever()\n</code></pre>"},{"location":"#with-a-title","title":"With a title","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#with-line-numbers","title":"With line numbers","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#icons-and-emojs","title":"Icons and Emojs","text":""},{"location":"Drone_Environment/","title":"Class for drone environment","text":"<p>Drones_Env(gym.Env)   Gym environment for controlling drones.     The goal of this environment is to control a drone to reach a target position while avoiding obstacles.</p> <pre><code>Observation:\n    - weight_pos_obj (array): Weighted position difference between the drone and the target.\n    - weight_pos_start (array): Weighted position difference between the drone and the initial position.\n    - weight_vel_obj (array): Weighted velocity difference between the drone and the target.\n    - weight_vel_start (array): Weighted velocity difference between the drone and the initial position.\n    - weight_ang (array): Sine of the difference between the drone's orientation and the initial orientation.\n    - weight_w (array): Weighted angular velocity difference between the drone and the initial angular velocity.\nAction:\n    - pvx0 (float): Desired velocity in the x-direction.\n    - pa0 (float): Desired angular velocity.\n    - pp0 (float): Desired power.\nReward:\n    The reward is based on the distance to the target and the drone's velocity. Higher rewards are given for\n    reaching the target with lower velocity.\nDone:\n    The episode is considered done when the drone reaches the target or exceeds the maximum number of allowed\n    actions.\n</code></pre>"},{"location":"Drone_Environment/#initself","title":"init(self):","text":"<pre><code>    Initializes the DroneEnv class.\n\n    The method sets up the observation space and action space for the drone environment.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n</code></pre>"},{"location":"Drone_Environment/#resetself-thetanone","title":"reset(self, theta=None):","text":"<pre><code>    Reset the environment to its initial state.\n\n    Args:\n        theta (float, optional): Angle of the target position. If not provided, a random angle is chosen.\n    Returns:\n        np.ndarray: The initial state of the environment.\n</code></pre>"},{"location":"Drone_Environment/#check_doneself","title":"check_done(self):","text":"<pre><code>    Check if the episode is done.\n    Returns:\n        bool: True if the episode is done, False otherwise.\n\ndef step(self, action):\n    \"\"\"\n    Take a step in the environment.\n    Args:\n        action (np.ndarray): The action to take.\n    Returns:\n        tuple: A tuple containing the next state, the reward, a flag indicating if the episode is done, and\n        additional information.\n</code></pre>"},{"location":"Drone_Environment/#helper-functions","title":"Helper functions:","text":""},{"location":"Drone_Environment/#plot_cylinderax-x-y-z-radius-height-num_points25-alpha08-colorblue","title":"plot_cylinder(ax, x, y, z, radius, height, num_points=25, alpha=0.8, color=\"blue\"):","text":"<pre><code>Plot a cylinder on the given axes.\nParameters:\n- ax: Axes object to plot on\n- x: x-coordinate of the cylinder center\n- y: y-coordinate of the cylinder center\n- z: z-coordinate of the cylinder base\n- radius: radius of the cylinder\n- height: height of the cylinder\n- num_points: number of points to use for the cylinder surface (default: 25)\n- alpha: transparency of the cylinder (default: 0.8)\n- color: color of the cylinder (default: 'blue')\n</code></pre>"},{"location":"Drone_Environment/#equationpvy0-pa0-pp0","title":"equation(pvy0, pa0, pp0):","text":"<pre><code>Calculate the time at which a drone reaches a certain position.\nParameters:\npvy0 (float): Initial vertical velocity of the drone.\npa0 (float): Initial vertical acceleration of the drone.\npp0 (float): Position of the drone at time t=0.\n\nReturns:\ntuple: A tuple containing the two possible times at which the drone reaches the given position.\n</code></pre>"},{"location":"Drone_Environment/#hamstate-tsa-tsb-tsc-end1","title":"ham(state, tsa, tsb, tsc, end=1):","text":"<pre><code>Calculates the hamiltonian value for a given state and time parameters.\nParameters:\nstate (numpy.ndarray): The state vector.\ntsa (float): Time parameter a.\ntsb (float): Time parameter b.\ntsc (float): Time parameter c.\nend (int, optional): End value. Defaults to 1.\nReturns:\nfloat: The calculated hamiltonian value.\n</code></pre>"},{"location":"Drone_Environment/#shootcostate-sf","title":"shoot(costate, sf):","text":"<pre><code>Shoots the drone towards a target state.\nParameters:\ncostate (numpy.ndarray): The costate vector.\nsf (list): The target state.\nReturns:\nfloat: The norm of the difference between the target state and the final state of the drone.\n</code></pre>"},{"location":"obstacles/","title":"Obstacles","text":"<p>This Python script uses reinforcement learning to simulate a drone navigating through an environment with obstacles. It employs the Proximal Policy Optimization algorithm (PPO) from Stable Baselines3. The drone adjusts its path based on obstacles, and the script visualizes the trajectory, obstacles, and final position. The simulation results, including scores and velocity components, are plotted.</p>"},{"location":"obstacles/#def-m_calcx0-y0","title":"def m_calc(x0, y0):","text":"<pre><code>Calculate the values of m1 and m2.\n\nParameters:\nx0 (float): The x-coordinate.\ny0 (float): The y-coordinate.\n\nReturns:\ntuple: A tuple containing the values of m1 and m2.\n</code></pre>"},{"location":"obstacles/#compute_directionp1-p2","title":"compute_direction(p1, p2):","text":"<pre><code>Compute the direction from point p1 to point p2.\n\nParameters:\np1 (tuple): The coordinates of point p1 in the form (x1, y1).\np2 (tuple): The coordinates of point p2 in the form (x2, y2).\n\nReturns:\nfloat: The direction in radians from p1 to p2.\n</code></pre>"},{"location":"optimal_control/","title":"Optimal control","text":"<p>This Python script utilizes numpy, TensorFlow, and scipy to model drone dynamics. It defines physical constants, drone parameters, and axis length. The code includes functions for calculating derivatives in drone dynamics (<code>f</code>), computing control inputs based on the state (<code>controls</code>), and a function for a linear system (<code>f_linear</code>). The simulation loop commented out for now, generates random initial conditions to simulate the drone's behaviour and plots various aspects of the simulation. The script focuses on numerical integration, providing a concise representation of drone dynamics under different conditions.</p>"},{"location":"optimal_control/#ft-state","title":"f(t, state):","text":"<pre><code>Calculate the derivative of the state vector for the drone dynamics.\n\nParameters:\nt (float): Time.\nstate (list): List containing the state variables [x, y, z, vx, vy, vz, a, b, c, p, q, r, T].\n\nReturns:\nnumpy.ndarray: Derivative of the state vector.\n</code></pre>"},{"location":"optimal_control/#controlsstate","title":"controls(state):","text":"<pre><code>Calculates the control inputs for the drone based on the current state.\n\nParameters:\nstate (array-like): Array containing the current state of the drone. The state should have the following elements:\n                    x, y, z, vx, vy, vz, a, b, c, p, q, r, px, py, pz, pvx, pvy, pvz, pa, pb, pc, pp, pq, pr, Time\nReturns:\narray-like: Array containing the control inputs for the drone. The control inputs are in the following order:\n            T0, Ma, Mb, Mc\n</code></pre>"},{"location":"optimal_control/#f_lineart-state-tsa-tsb-tf-obj","title":"f_linear(t, state, tsa, tsb, tf, obj):","text":"<pre><code>Calculates the derivative of the state vector for a linear system.\nArgs:\n    t (float): Current time.\n    state (numpy.ndarray): State vector containing the current values of the system variables.\n    tsa (list): List of two time points representing the start and end of a time interval.\n    tsb (list): List of two time points representing the start and end of another time interval.\n    tf (float): Final time.\n    obj (numpy.ndarray): Object coordinates.\nReturns:\n    numpy.ndarray: Derivative of the state vector.\n</code></pre>"}]}